# libFuzzer

## What is libFuzzer?

https://llvm.org/docs/LibFuzzer.html

libFuzzer is a greybox fuzzer provided as a part of the compiler-rt libraries of the LLVM project. We reimplemented it in fuzzuf because it is widely used and is the base of the current fuzzing research.

libFuzzer creates new input values by mutation based on the input values recorded in the corpus, executes a PUT with them, checks the coverage, and adds them to the corpus if rare paths are taken or if rare behaviors are observed. In this respect, libFuzzer is a fuzzer that is roughly similar to AFL but differs from AFL in the following points:

* Has a mutator that parses a random range of input values as if they were integers written in text, performs arithmetic operations on them, and then rewrites them back to their original positions (ChangeASCIIInt)
* Has a mutator that takes two input values as arguments and randomly mixes them (Crossover).
* A mutator that logs comparison operations using LLVM's `-fsanitize-coverage=trace-cmp`, and uses the values on both sides of the comparison as a dictionary (CMP)
* Persistent Auto Dictionary automatically registers words in the dictionary when the fuzzer adds an input value created using the dictionary to the corpus.
* If a new input value created after a given number of mutation runs (default 100) cannot get a new result for the corpus, the fuzzer will retry mutation on the same input value up to a specified number of times (default 5).
* It is possible to specify that only a specific range of input values should be mutated (Mask).
* In LLVM 10 and later, the fuzzer calculates how valuable an execution result value is (energy) by how many unusual paths the run took (feature). The energy affects the probability of an input value selection from the corpus (entropic scheduling). In LLVM 9 and earlier, the results of a run that find one or more new features are weighted (vanilla scheduling) so that the fuzzer choose the features found later features with a higher probability.
* If the number of known features reaches the maximum number of feature types when the fuzzer finds a new feature, the features that commonly appear in the most number of executions (abundant features) will be ignored. Ignored features will no longer affect the calculation of energy. As a result, even if the fuzzer judged the result to be rare, its value will decrease if similar runs are found frequently and will be removed from the corpus when it becomes worthless (energy == 0).
* If the fuzzer found a shorter input value that yields the same feature as the previous run, the corpus element is replaced by the shorter one (reduce).

libFuzzer calls a function called harness with the new input value created by mutation as an argument. The user implements the harness that calls the function to be fuzzed using the input value generated by libFuzzer and links libFuzzer with the library that contains the target function. Such a fuzzing method has a performance advantage over the classical fuzzer implementation that spawns child processes (generating child processes is generally time-consuming).

Since the target and fuzzer are in the same process, the following problems occur.

1. The fuzzer should not count coverage of the fuzzer itself.
2. When the sanitizer reports a problem, it needs to distinguish whether it is reported by the fuzzing target or by the fuzzer itself.

To support 1., libFuzzer will link the target built with `-fsanitize-coverage=edge` and the libFuzzer library built without `-fsanitize-coverage=edge`. It is carefully implemented so that inline functions in libFuzzer are not compiled during the build of the fuzzing target. On the other hand, it does not care that it counts the harness coverage.

To achieve 2., libFuzzer rewrites the information held by the sanitizer before and after executing the harness, if necessary.
The implementation of LLVM's sanitizer is not an API that guarantees to be compatible in the future. Since libFuzzer itself is part of LLVM, it is implemented to be coupled with the corresponding version of LLVM's sanitizer.
