# libFuzzer

## What is libFuzzer?

https://llvm.org/docs/LibFuzzer.html

libFuzzer is a greybox fuzzer provided as a part of the compiler-rt libraries of the LLVM project. We reimplemented it in fuzzuf because it is widely used and is the base of the current fuzzing research.

libFuzzer creates new input values by mutation based on the input values recorded in the corpus, executes a PUT with them, checks the coverage, and adds them to the corpus if rare paths are taken or if rare behaviors are observed. In this respect, libFuzzer is a fuzzer that is roughly similar to AFL but differs from AFL in the following points:

* Has a mutator that parses a random range of input values as if they were integers written in text, performs arithmetic operations on them, and then rewrites them back to their original positions (ChangeASCIIInt)
* Has a mutator that takes two input values as arguments and randomly mixes them (Crossover).
* A mutator that logs comparison operations using LLVM's `-fsanitize-coverage=trace-cmp`, and uses the values on both sides of the comparison as a dictionary (CMP)
* Persistent Auto Dictionary automatically registers words in the dictionary when the fuzzer adds an input value created using the dictionary to the corpus.
* If a new input value created after a given number of mutation runs (default 100) cannot get a new result for the corpus, the fuzzer will retry mutation on the same input value up to a specified number of times (default 5).
* It is possible to specify that only a specific range of input values should be mutated (Mask).
* In LLVM 10 and later, the fuzzer calculates how valuable an execution result value is (energy) by how many unusual paths the run took (feature). The energy affects the probability of an input value selection from the corpus (entropic scheduling). In LLVM 9 and earlier, the results of a run that find one or more new features are weighted (vanilla scheduling) so that the fuzzer choose the features found later features with a higher probability.
* If the number of known features reaches the maximum number of feature types when the fuzzer finds a new feature, the features that commonly appear in the most number of executions (abundant features) will be ignored. Ignored features will no longer affect the calculation of energy. As a result, even if the fuzzer judged the result to be rare, its value will decrease if similar runs are found frequently and will be removed from the corpus when it becomes worthless (energy == 0).
* If the fuzzer found a shorter input value that yields the same feature as the previous run, the corpus element is replaced by the shorter one (reduce).

libFuzzer calls a function called harness with the new input value created by mutation as an argument. The user implements the harness that calls the function to be fuzzed using the input value generated by libFuzzer and links libFuzzer with the library that contains the target function. Such a fuzzing method has a performance advantage over the classical fuzzer implementation that spawns child processes (generating child processes is generally time-consuming).

Since the target and fuzzer are in the same process, the following problems occur.

1. The fuzzer should not count coverage of the fuzzer itself.
2. When the sanitizer reports a problem, it needs to distinguish whether it is reported by the fuzzing target or by the fuzzer itself.

To support 1., libFuzzer will link the target built with `-fsanitize-coverage=edge` and the libFuzzer library built without `-fsanitize-coverage=edge`. It is carefully implemented so that inline functions in libFuzzer are not compiled during the build of the fuzzing target. On the other hand, it does not care that it counts the harness coverage.

To achieve 2., libFuzzer rewrites the information held by the sanitizer before and after executing the harness, if necessary.
The implementation of LLVM's sanitizer is not an API that guarantees to be compatible in the future. Since libFuzzer itself is part of LLVM, it is implemented to be coupled with the corresponding version of LLVM's sanitizer.

As mentioned in the previous section on feature behavior, the original libFuzzer has some minor differences in behavior depending on the version. For example, up to LLVM 8, mt19937 is used as the random number generator, and after LLVM 9, minstd_rand is used.

## How libFuzzer works

libFuzzer performs the process shown in the following pseudo-code.

Where `initial_input` is the initial seed, `target` is the fuzzing target, `total_count` is the number of times to execute the target, and `mutation_depth` is the number of times to perform mutation on the same input value.

```cpp
count = 0;
// Array of IDs of "unique" features that have appeared more than once but less frequently.
unique_feature_set = {}
// A map holding the number of times a feature has appeared.
global_feature_freqs = {}
corpus = {}
// For all initial seeds:
for( input in initial_inputs ) {
  // Execute the target once.
  exec_result = execute( target, input );
  // Add the execution result to the corpus.
  add_to_corpus( corpus, exec_result, input );
}
// Update the distribution of the probability of selecting the input value.
dist = update_distribution( corpus );
// Until the number of attempts reaches total_count:
while( count < total_count ) {
  // Until `i` reaches mutation_depth (default to 5 in libFuzzer):
  for( i = 0; i < mutation_depth; ++i ) {
    // Select a input value from corpus.
    [old_exec_result,input] = corpus.select_seed();
    // Perform mutation on the input value.
    mut_input = mutate( dist, input );
    // Execute the target.
    exec_result = execute( target, mut_input );
    // Collect the features from the execution result.
    features = collect_features( old_exec_result, exec_result, unique_feature_set, global_feature_freqs );
    // If a new feature has been discovered:
    if( is_interesting( features ) ) {
      // Add the execution result and the input value to corpus.
      corpus.add( exec_result, mut_input );
      // Update the distribution of the probability of selecting the input value.
      dist = update_distribution( corpus );
      // Increment the attempt counter.
      ++count;
      // Exit the loop if the execution result is added to corpus, even if `i` does not reach mutation_depth.
      break;
    }
    else {
      // Increment the attempt counter.
      ++count;
    }
  }
}
```

libFuzzer treats "features of interest" in the target execution results and gives them IDs.
Features are the index of the edge in the edge coverage and the number of hits on the edge.

In the pseudo code above, `collect_features()` collects features from `exec_result` of the current seed execution. `collect_features()` updates `unique_feature_set` and `global_feature_freqs` each time a feature is found.

If there is a new feature in `features` collected by `collect_features()`, `corpus.add()` will add its execution result `exec_result` and the mutated input value `mut_input` to corpus. `is_interesting()` checks if `features` contains at least one "rare" feature from `unique_feature_set`. Finally, the probability `dist` of choosing the next input value is updated with `update_distribution()`.

There are two types of behavior of `update_distribution()`, vanilla scheduling and entropic scheduling, and the libFuzzer implementation of fuzzuf uses the former by default. In vanilla scheduling, libFuzzer uses a simple "select more recently found items with higher probability" policy. On the other hand, entropic scheduling evaluates the results of the seed runs and updates the probability distribution `dist` so that the results with higher evaluation are more likely to be selected in the next `select_seed()`. The evaluation value of the result of this seed run used in entropic scheduling is called energy, and the fuzzer calculates it while collecting features with `collect_features()` in the following terms:

* The number of "rare" features found.
* The number of mutations performed from the initial seed to this input value.
* How deviated from the average execution time is.

In entropic scheduling, libFuzzer selects the seed according to the following policy by using energy:

* Focus on the input that produced the rarest features
* Select inputs that have repeatedly found new features with each mutation.
* Select inputs that run more quickly if the same number of features are found.
