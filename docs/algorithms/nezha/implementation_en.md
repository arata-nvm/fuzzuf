# Implementation of Nezha in fuzzuf

In this section, we describe the implementation of Nezha in fuzzuf.

The [original implementation](https://github.com/nezha-dt/nezha/tree/master/Fuzzer) of Nezha is more of a proof of concept than a practical fuzzer that we can apply to any software.

Nezha decides which elements to add to solutions by looking at the "execution result differences" of multiple targets, but the original implementation assumes that a single 32-bit integer can represent the execution result.

For example, Nezha's original implementation sample uses a target that checks for X.509 certificates using multiple TLS implementations. The output of the target is only four types: the certificate was correct (0), incorrect (1), could not be parsed (0xFFFFFFF0) or failed for some other reason (0xFFFFFFFF), and the harness always returns one of these four as the return value. Because of this harness, the original Nezha implementation only looks at the target's exit status and assumes that it has "seen the execution result."

A straightforward implementation of this in fuzzuf leads to the following two problems:

* Nezha's harness returns the execution result as its enum value, without the exit status of the target, so the executor can only get information about whether the execution was successful or not.
* Nezha assumes a code in the harness to encode the execution result into an integer, but fuzzuf assumes that the target is not modified, so it is not possible to insert such a code.

As a result, if we try to implement the original Nezha as similarly as possible in fuzzuf, we end up with an implementation that only compares whether it crashes or not, rather than taking the difference in execution results, which is far from the method described in the paper.

Therefore, we show that fuzzuf can recombine HierarFlow into two versions: one implementation based on exit status, which is closer to the original implementation. The other compares hashes of the standard output to get results closer to those described in the paper.

## How to Construct the Standard Nezha

The fuzzer corresponding to `Fuzzer::Loop()` in the original Nezha is implemented as `createRunone()` in [include/fuzzuf/algorithms/nezha/create.hpp](/include/fuzzuf/algorithms/nezha/create.hpp). You can use the Nezha implementation in fuzzuf by using this function when you use it as a standard libFuzzer.

## The Branch Position of Nezha from libFuzzer

In the Nezha repository on GitHub, the Nezha implementation is mixed with the addition of libFuzzer code and following new versions in one commit, so it is not clear at what point Nezha forked from LLVM.

By comparing libFuzzer's history and Nezha's code, we can assume that Nezha was forked when the difference was the smallest. The current master of Nezha probably forked from between the time LLVM 4.x branch branched off from LLVM master and LLVM 5.0.0-rc1 was created. The diffs of Nezha's master and LLVM 5.0.0-rc1 are attached in [docs/algorithms/nezha/nezha-5.0.0-rc1.diff](/docs/algorithms/nezha/nezha-5.0.0-rc1.diff).

## HierarFlow Nodes for Nezha Implementation

We implement the following Nezha-specific nodes to represent Nezha in HierarFlow. For more details about each node, refer to the comments in the source code or the documentation generated by Doxygen.

* [CollectFeatures](/include/fuzzuf/algorithms/nezha/hierarflow/collect_features.hpp)
* [AddToSolution](/include/fuzzuf/algorithms/nezha/hierarflow/add_to_solution.hpp)
* [GatherOutput](/include/fuzzuf/algorithms/nezha/hierarflow/gather.hpp)

## Unimplemented Features

Some Nezha features are unimplemented in fuzzuf:

### Blackbox Fuzzing

The original Nezha implementation does not have blackbox fuzzing. In Nezha's paper, blackbox fuzzing is also available using the execution result instead of the coverage to determine if the fuzzer adds the item to the corpus. However, there is no obvious way to compute the feature of libFuzzer other than coverage. For this reason, fuzzuf does not implement the blackbox fuzzing version of Nezha.

### δ-diversity

Nezha's paper mentions that the δ-diversity is calculated from the coverage tuple to decide whether to add the execution result to the corpus or not. However, there is no such calculation in the code implemented in Nezha.

What is done is that each time the fuzzer executes each target, it adds the result of the execution to the corpus using the original libFuzzer implementation. The edge indexes of the individual targets have offset, resulting in the same δ-diversity as described in the paper. In other words, the δ-diversity is a post-processing explanation for a simple modification of libFuzzer that behaved like that.
We implemented Nezha in fuzzuf using the nodes of libFuzzer in fuzzuf, so the process of calculating δ-diversity does not appear explicitly as in the original implementation.
